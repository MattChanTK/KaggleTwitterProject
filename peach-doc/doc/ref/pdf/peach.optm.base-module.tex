%
% API Documentation for Peach - Computational Intelligence for Python
% Module peach.optm.base
%
% Generated by epydoc 3.0.1
% [Sun Jul 31 17:00:41 2011]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{peach \textit{(package)}!peach.optm \textit{(package)}!peach.optm.base \textit{(module)}|(}
\section{Module peach.optm.base}

    \label{peach:optm:base}

Basic definitons and base class for optimizers

This sub-package exports some auxiliary functions to work with cost functions,
namely, a function to calculate gradient vectors and hessian matrices, which are
extremely important in optimization.

Also, a base class, \texttt{Optimizer}, for all optimizers. Sub-class this class if
you want to create your own optmizer, and follow the interface. This will allow
easy configuration of your own scripts and comparison between methods.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Functions                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Functions}

    \label{peach:optm:base:gradient}
    \index{peach \textit{(package)}!peach.optm \textit{(package)}!peach.optm.base \textit{(module)}!peach.optm.base.gradient \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{gradient}(\textit{f}, \textit{dx}={\tt 1e-05})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}

Creates a function that computes the gradient vector of a scalar field.

This function takes as a parameter a scalar function and creates a new
function that is able to compute the derivative (in case of single variable
functions) or the gradient vector (in case of multivariable functions.
Please, note that this function takes as a parameter a \emph{function}, and
returns as a result \emph{another function}. Calling the returned function on a
point will give the gradient vector of the original function at that point:
%
\begin{quote}{\ttfamily \raggedright \noindent
>{}>{}>~def~f(x):\\
~~~~~~~~return~x\textasciicircum{}2\\
~\\
>{}>{}>~df~=~gradient(f)\\
>{}>{}>~df(1)\\
2
}
\end{quote}

In the above example, \texttt{df} is a generated function which will return the
result of the expression \texttt{2*x}, the derivative of the original function.
In the case \texttt{f} is a multivariable function, it is assumed that its
argument is a line vector.
\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xx}

          \item[f]


Any function, one- or multivariable. The function must be an scalar
function, though there is no checking at the moment the function is
created. If \texttt{f} is not an scalar function, an exception will be
raised at the moment the returned function is used.
          \item[dx]


Optional argument that gives the precision of the calculation. It is
recommended that \texttt{dx = sqrt(D)}, where \texttt{D} is the machine precision.
It defaults to \texttt{1e-5}, which usually gives a good estimate.
        \end{Ventry}

      \end{quote}

      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}

A new function which, upon calling, gives the derivative or gradient
vector of the original function on the analised point. The parameter of
the returned function is a real number or a line vector where the gradient
should be calculated.
      \end{quote}

    \end{boxedminipage}

    \label{peach:optm:base:hessian}
    \index{peach \textit{(package)}!peach.optm \textit{(package)}!peach.optm.base \textit{(module)}!peach.optm.base.hessian \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{hessian}(\textit{f}, \textit{dx}={\tt 1e-05})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}

Creates a function that computes the hessian matrix of a scalar field.

This function takes as a parameter a scalar function and creates a new
function that is able to calculate the second derivative (in case of single
variable functions) or the hessian matrix (in case of multivariable
functions. Please, note that this function takes as a parameter a
\emph{function}, and returns as a result \emph{another function}. Calling the returned
function on a point will give the hessian matrix of the original function
at that point:
%
\begin{quote}{\ttfamily \raggedright \noindent
>{}>{}>~def~f(x):\\
~~~~~~~~return~x\textasciicircum{}4\\
~\\
>{}>{}>~ddf~=~hessian(f)\\
>{}>{}>~ddf(1)\\
12
}
\end{quote}

In the above example, \texttt{ddf} is a generated function which will return the
result of the expression \texttt{12*x**2}, the second derivative of the original
function. In the case \texttt{f} is a multivariable function, it is assumed that
its argument is a line vector.
\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xx}

          \item[f]


Any function, one- or multivariable. The function must be an scalar
function, though there is no checking at the moment the function is
created. If \texttt{f} is not an scalar function, an exception will be
raised at the moment the returned function is used.
          \item[dx]


Optional argument that gives the precision of the calculation. It is
recommended that \texttt{dx = sqrt(D)}, where \texttt{D} is the machine precision.
It defaults to \texttt{1e-5}, which usually gives a good estimate.
        \end{Ventry}

      \end{quote}

      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}

A new function which, upon calling, gives the second derivative or hessian
matrix of the original function on the analised point. The parameter of
the returned function is a real number or a line vector where the hessian
should be calculated.
      \end{quote}

    \end{boxedminipage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Variables                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright \_\-\_\-d\-o\-c\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt \texttt{...}}&\\
\cline{1-2}
\raggedright \_\-\_\-p\-a\-c\-k\-a\-g\-e\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{peach.optm}\texttt{'}}&\\
\cline{1-2}
\end{longtable}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{peach \textit{(package)}!peach.optm \textit{(package)}!peach.optm.base \textit{(module)}!peach.optm.base.Optimizer \textit{(class)}|(}
\subsection{Class Optimizer}

    \label{peach:optm:base:Optimizer}
\begin{tabular}{cccccc}
% Line for object, linespec=[False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
  \\
&&\multicolumn{2}{l}{\textbf{peach.optm.base.Optimizer}}
\end{tabular}

\textbf{Known Subclasses:}
peach.optm.quasinewton.BFGS,
    peach.optm.quasinewton.DFP,
    peach.optm.quasinewton.SR1,
    peach.optm.linear.Direct1D,
    peach.optm.linear.Fibonacci,
    peach.optm.linear.GoldenRule,
    peach.optm.linear.Interpolation,
    peach.optm.multivar.Direct,
    peach.optm.multivar.Gradient,
    peach.optm.multivar.MomentumGradient,
    peach.optm.multivar.Newton


Base class for all optimizers.

This class does nothing, and shouldn't be instantiated. Its only purpose is
to serve as a template (or interface) to implemented optimizers. To create
your own optimizer, subclass this.

This class defines 3 methods that should be present in any subclass. They
are defined here:
%
\begin{quote}
%
\begin{description}
\item[{\_\_init\_\_}] \leavevmode 
Initializes the optimizer. There are three usual parameters in this
method, which signature should be:
%
\begin{quote}{\ttfamily \raggedright \noindent
\_\_init\_\_(self,~f,~x0,~...,~emax=1e-8,~imax=1000)
}
\end{quote}
%
\begin{description}
\item[{where:}] \leavevmode %
\begin{itemize}

\item \texttt{f} is the cost function to be minimized;

\item \texttt{x0} is the first estimate of the location of the minimum;

\item \texttt{...} represent additional configuration of the optimizer, and it
is dependent of the technique implemented;

\item \texttt{emax} is the maximum allowed error. The default value above is
only a suggestion;

\item \texttt{imax} is the maximum number of iterations of the method. The
default value above is only a suggestions.

\end{itemize}

\end{description}

\item[{step()}] \leavevmode 
This method should take an estimate and calculate the next, possibly
better, estimate. Notice that the next estimate is strongly dependent of
the method, the optimizer state and configuration, and two calls to this
method with the same estimate might not give the same results. The
method signature is:
%
\begin{quote}{\ttfamily \raggedright \noindent
step(self)
}
\end{quote}

and the implementation should keep track of all the needed parameters.
The method should return a tuple \texttt{(x, e)} with the new estimate of the
solution and the estimate of the error.

\item[{restart()}] \leavevmode 
Implement this method to restart the optimizer. An optimizer might be
restarted for a number of reasons: to escape a local minimum, to try
different estimates and so on. This method should take at least one
argument, \texttt{x0}, a new estimate for the optimizer. Optionally, new
configuration might be given, but, if not, the old ones must be used.

\item[{\_\_call\_\_}] \leavevmode 
This method should take an estimate and iterate the optimizer until one
of the stop criteria is met: either less than the maximum error or more
than the maximum number of iterations. Error is usually calculated as an
estimate using the previous estimate, but any technique might be used.
Use a counter to keep track of the number of iterations. The method
signature is:
%
\begin{quote}{\ttfamily \raggedright \noindent
\_\_call\_\_(self)
}
\end{quote}

and the implementation should keep track of all the needed parameters.
The method should return a tuple \texttt{(x, e)} with the final estimate of
the solution and the estimate of the error.

\end{description}

\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{f}={\tt None}, \textit{x0}={\tt None}, \textit{emax}={\tt 1e-08}, \textit{imax}={\tt 1000})

\setlength{\parskip}{2ex}

x.\_\_init\_\_(...) initializes x; see x.\_\_class\_\_.\_\_doc\_\_ for signature
\setlength{\parskip}{1ex}
      Overrides: object.\_\_init\_\_ 	extit{(inherited documentation)}

    \end{boxedminipage}

    \label{peach:optm:base:Optimizer:step}
    \index{peach \textit{(package)}!peach.optm \textit{(package)}!peach.optm.base \textit{(module)}!peach.optm.base.Optimizer \textit{(class)}!peach.optm.base.Optimizer.step \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{step}(\textit{self}, \textit{x})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{peach:optm:base:Optimizer:__call__}
    \index{peach \textit{(package)}!peach.optm \textit{(package)}!peach.optm.base \textit{(module)}!peach.optm.base.Optimizer \textit{(class)}!peach.optm.base.Optimizer.\_\_call\_\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_call\_\_}(\textit{self}, \textit{x})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}


\large{\textbf{\textit{Inherited from object}}}

\begin{quote}
\_\_delattr\_\_(), \_\_format\_\_(), \_\_getattribute\_\_(), \_\_hash\_\_(), \_\_new\_\_(), \_\_reduce\_\_(), \_\_reduce\_ex\_\_(), \_\_repr\_\_(), \_\_setattr\_\_(), \_\_sizeof\_\_(), \_\_str\_\_(), \_\_subclasshook\_\_()
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Properties                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Properties}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\multicolumn{2}{|l|}{\textit{Inherited from object}}\\
\multicolumn{2}{|p{\varwidth}|}{\raggedright \_\_class\_\_}\\
\cline{1-2}
\end{longtable}

    \index{peach \textit{(package)}!peach.optm \textit{(package)}!peach.optm.base \textit{(module)}!peach.optm.base.Optimizer \textit{(class)}|)}
    \index{peach \textit{(package)}!peach.optm \textit{(package)}!peach.optm.base \textit{(module)}|)}
