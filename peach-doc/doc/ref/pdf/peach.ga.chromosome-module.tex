%
% API Documentation for Peach - Computational Intelligence for Python
% Module peach.ga.chromosome
%
% Generated by epydoc 3.0.1
% [Sun Jul 31 17:00:40 2011]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{peach \textit{(package)}!peach.ga \textit{(package)}!peach.ga.chromosome \textit{(module)}|(}
\section{Module peach.ga.chromosome}

    \label{peach:ga:chromosome}

Basic definitions and classes for manipulating chromosomes

This sub-package is a vital part of the genetic algorithms framework within the
module. This uses the \texttt{bitarray} module to implement a chromosome as an array
of bits. It is, thus, necessary that this module is installed in your Python
system. Please, check within the Python website how to install the \texttt{bitarray}
module.

The class defined in this module is derived from \texttt{bitarray} and can also be
derived if needed. In general, users or programmers won't need to instance this
class directly -{}- it is manipulated by the genetic algorithm itself. Check the
class definition for more information.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Variables                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright \_\-\_\-d\-o\-c\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt \texttt{...}}&\\
\cline{1-2}
\raggedright \_\-\_\-p\-a\-c\-k\-a\-g\-e\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{peach.ga}\texttt{'}}&\\
\cline{1-2}
\end{longtable}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{peach \textit{(package)}!peach.ga \textit{(package)}!peach.ga.chromosome \textit{(module)}!peach.ga.chromosome.Chromosome \textit{(class)}|(}
\subsection{Class Chromosome}

    \label{peach:ga:chromosome:Chromosome}
\begin{tabular}{cccccccccc}
% Line for object, linespec=[False, False, False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
&&
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
&&
&&
  \\
% Line for bitarray.\_bitarray, linespec=[False, False]
\multicolumn{4}{r}{\settowidth{\BCL}{bitarray.\_bitarray}\multirow{2}{\BCL}{bitarray.\_bitarray}}
&&
&&
  \\\cline{5-5}
  &&&&\multicolumn{1}{c|}{}
&&
&&
  \\
% Line for bitarray.bitarray, linespec=[False]
\multicolumn{6}{r}{\settowidth{\BCL}{bitarray.bitarray}\multirow{2}{\BCL}{bitarray.bitarray}}
&&
  \\\cline{7-7}
  &&&&&&\multicolumn{1}{c|}{}
&&
  \\
&&&&&&\multicolumn{2}{l}{\textbf{peach.ga.chromosome.Chromosome}}
\end{tabular}


Implements a chromosome as a bit array.

Data is structured according to the \texttt{struct} module that exists in the
Python standard library. Internally, data used in optimization with a
genetic algorithm are represented as arrays of bits, so the \texttt{bitarray}
module must be installed. Please consult the Python package index for more
information on how to install \texttt{bitarray}. In general, the user don't need
to worry about how the data is manipulated internally, but a specification
of the format as in the \texttt{struct} module is needed.

If the internal format of the data is specified as an \texttt{struct} format, the
genetic algorithm will take care of encoding and decoding data from and to
the optimizer. However, it is possible to specify, instead of a format, the
length of the chromosome. In that case, the fitness function must deal with
the encoding and decoding of the information. It is strongly suggested that
you use \texttt{struct} format strings, as they are much easier. This second
option is provided as a convenience.

The \texttt{Chromosome} class is derived from the \texttt{bitarray} class. So, every
property and method of this class should be accessible.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_new\_\_}(\textit{cls}, \textit{fmt}={\tt \texttt{'}\texttt{}\texttt{'}}, \textit{endian}={\tt \texttt{'}\texttt{little}\texttt{'}})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}

Allocates new memory space for the chromosome

This function overrides the \texttt{bitarray.\_\_new\_\_} function to deal with
the length of the chromosome. It should never be directly used, as it is
automatically called by the Python interpreter in the moment of object
creation.
\setlength{\parskip}{1ex}
      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}

A new \texttt{Chromosome} object.
      {\it (type=a new object with type S, a subtype of T)}

      \end{quote}

      Overrides: object.\_\_new\_\_

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{fmt}={\tt \texttt{'}\texttt{}\texttt{'}})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}

Initializes the chromosome.

This method is automatically called by the Python interpreter and
initializes the data in the chromosome. No data should be provided to be
encoded in the chromosome, as it is usually better start with random
estimates. This method, in particular, does not clear the memory used in
the time of creation of the \texttt{bitarray} from which a \texttt{Chromosome}
derives -{}- so the random noise in the memory is used as initial value.
\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xxx}

          \item[fmt]


This parameter can be passed in two different ways. If \texttt{fmt} is a
string, then it is assumed to be a \texttt{struct}-format string. Its
size is calculated and a \texttt{bitarray} of the corresponding size is
created. Please, consult the \texttt{struct} documentation, since what is
explained there is exactly what is used here. For example, if you
are going to use the optimizer to deal with three-dimensional
vectors of continuous variables, the format would be something
like:
%
\begin{quote}{\ttfamily \raggedright \noindent
fmt~=~'fff'
}
\end{quote}

If \texttt{fmt}, however, is an integer, then a \texttt{bitarray} of the given
length is created. Note that, in this case, no format is given to
the chromosome, and it is responsability of the programmer and the
fitness function to provide for it.

Default value is an empty string.
        \end{Ventry}

      \end{quote}

      Overrides: object.\_\_init\_\_

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{decode}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}

This method decodes the information given in the chromosome.

Data in the chromosome is encoded as a \texttt{struct}-formated string in a
\texttt{bitarray} object. This method decodes the information and returns the
encoded values. If a format string is not given, then it is assumed that
this chromosome is just an array of bits, which is returned.
\setlength{\parskip}{1ex}
      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}

A tuple containing the decoded values, in the order specified by the
format string.
      \end{quote}

      Overrides: bitarray.bitarray.decode

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{encode}(\textit{self}, \textit{values})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}

This method encodes the information into the chromosome.

Data in the chromosome is encoded as a \texttt{struct}-formated string in a
\texttt{bitarray} object. This method encodes the given information in the
bitarray. If a format string is not given, this method raises a
\texttt{TypeError} exception.
\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xxxxxx}

          \item[values]


A tuple containing the values to be encoded in an order consistent
with the given \texttt{struct}-format.
        \end{Ventry}

      \end{quote}

      Overrides: bitarray.bitarray.encode

    \end{boxedminipage}


\large{\textbf{\textit{Inherited from bitarray.bitarray}}}

\begin{quote}
\_\_contains\_\_(), search()
\end{quote}

\large{\textbf{\textit{Inherited from bitarray.\_bitarray}}}

\begin{quote}
\_\_add\_\_(), \_\_and\_\_(), \_\_copy\_\_(), \_\_deepcopy\_\_(), \_\_delitem\_\_(), \_\_eq\_\_(), \_\_ge\_\_(), \_\_getattribute\_\_(), \_\_getitem\_\_(), \_\_gt\_\_(), \_\_iadd\_\_(), \_\_iand\_\_(), \_\_imul\_\_(), \_\_invert\_\_(), \_\_ior\_\_(), \_\_iter\_\_(), \_\_ixor\_\_(), \_\_le\_\_(), \_\_len\_\_(), \_\_lt\_\_(), \_\_mul\_\_(), \_\_ne\_\_(), \_\_or\_\_(), \_\_reduce\_\_(), \_\_repr\_\_(), \_\_rmul\_\_(), \_\_setitem\_\_(), \_\_xor\_\_(), all(), any(), append(), buffer\_info(), bytereverse(), copy(), count(), endian(), extend(), fill(), fromfile(), fromstring(), index(), insert(), invert(), length(), pack(), pop(), remove(), reverse(), setall(), sort(), to01(), tofile(), tolist(), tostring(), unpack()
\end{quote}

\large{\textbf{\textit{Inherited from object}}}

\begin{quote}
\_\_delattr\_\_(), \_\_format\_\_(), \_\_hash\_\_(), \_\_reduce\_ex\_\_(), \_\_setattr\_\_(), \_\_sizeof\_\_(), \_\_str\_\_(), \_\_subclasshook\_\_()
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Properties                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Properties}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright s\-i\-z\-e\- & &\\
\cline{1-2}
\multicolumn{2}{|l|}{\textit{Inherited from object}}\\
\multicolumn{2}{|p{\varwidth}|}{\raggedright \_\_class\_\_}\\
\cline{1-2}
\end{longtable}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Instance Variables                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Instance Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright f\-o\-r\-m\-a\-t\- & Property that contains the chromosome \texttt{struct} format.&\\
\cline{1-2}
\end{longtable}

    \index{peach \textit{(package)}!peach.ga \textit{(package)}!peach.ga.chromosome \textit{(module)}!peach.ga.chromosome.Chromosome \textit{(class)}|)}
    \index{peach \textit{(package)}!peach.ga \textit{(package)}!peach.ga.chromosome \textit{(module)}|)}
